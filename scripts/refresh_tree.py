#!/usr/bin/env python3
"""
Generate a textual tree of the repository, ignoring patterns from .gitignore
and some common autogenerated files. Optionally run in watch mode (polling)
to update the tree file when the tree changes.

Usage:
  # one-shot
  python scripts/refresh_tree.py

  # watch mode (regenerates every 5 seconds by default)
  python scripts/refresh_tree.py --watch --interval 5

Outputs:
  - tree file at ./PROJECT_TREE.txt (overwritten when changed)
  - prints to stdout when run
"""
from __future__ import annotations
import argparse
import fnmatch
import os
import pathlib
import time
import hashlib
from typing import List, Set

DEFAULT_IGNORE = {
    "__pycache__",
    "*.pyc",
    "*.pyo",
    "*.pyd",
    ".pytest_cache",
    ".mypy_cache",
    ".venv",
    "venv",
    ".env",
    "env",
    "node_modules",
    "dist",
    "build",
    ".DS_Store",
    "*.log",
    ".idea",
    ".vscode",
    ".pytest_cache",
    "*.egg-info",
    "*.egg",
    ".ipynb_checkpoints",
    ".terraform",
}

OUTPUT_FILE = "PROJECT_TREE.txt"


def load_gitignore(project_root: pathlib.Path) -> List[str]:
    gitignore = project_root / ".gitignore"
    patterns = []
    if gitignore.exists():
        for raw in gitignore.read_text(encoding="utf-8").splitlines():
            line = raw.strip()
            if not line or line.startswith("#"):
                continue
            patterns.append(line)
    return patterns


def path_matches_pattern(path: pathlib.Path, pattern: str, project_root: pathlib.Path) -> bool:
    """
    Test whether a path (file or directory) matches a .gitignore-style pattern.
    This implements a pragmatic subset of .gitignore behavior:
      - supports globs like *.pyc, build/, docs/*.html
      - leading slash means relative to repo root
      - trailing slash treats pattern as directory
    It is not a full .gitignore engine but handles the common cases.
    """
    p = path.as_posix()
    rel = path.relative_to(project_root).as_posix() if project_root in path.parents or path == project_root else p

    pat = pattern
    is_dir_pattern = pat.endswith("/")
    if is_dir_pattern:
        pat = pat.rstrip("/")

    # If pattern starts with slash: match from repo root
    if pat.startswith("/"):
        pat = pat.lstrip("/")
        return fnmatch.fnmatch(rel, pat) or (is_dir_pattern and fnmatch.fnmatch(rel + "/", pat + "/"))

    # Otherwise, match anywhere in path
    # Try matching basename and whole relative path
    base = path.name
    if fnmatch.fnmatch(base, pat):
        return True
    if fnmatch.fnmatch(rel, pat) or fnmatch.fnmatch("*/" + rel, "*" + pat):
        return True

    # fallback: try matching with wildcard anywhere
    return fnmatch.fnmatch(rel, f"**/{pat}")


def should_ignore(path: pathlib.Path, gitignore_patterns: List[str], project_root: pathlib.Path) -> bool:
    name = path.name
    # always ignore the script output to avoid feedback loops
    if path.name == OUTPUT_FILE:
        return True
    # builtin ignores
    for pat in DEFAULT_IGNORE:
        if fnmatch.fnmatch(name, pat) or fnmatch.fnmatch(path.as_posix(), pat) or fnmatch.fnmatch(path.as_posix()+"/", pat):
            return True
    # gitignore patterns
    for pat in gitignore_patterns:
        try:
            if path_matches_pattern(path, pat, project_root):
                return True
        except Exception:
            # be conservative and don't ignore if parsing fails
            continue
    return False


def build_tree(project_root: pathlib.Path, gitignore_patterns: List[str]) -> str:
    lines = []
    project_root = project_root.resolve()
    prefix_stack: List[bool] = []  # whether the parent had more siblings

    def walk(dir_path: pathlib.Path, indent: str = ""):
        try:
            entries = sorted([p for p in dir_path.iterdir()], key=lambda p: (p.is_file(), p.name.lower()))
        except PermissionError:
            return

        # filter out ignored entries
        entries = [e for e in entries if not should_ignore(e, gitignore_patterns, project_root)]

        for i, entry in enumerate(entries):
            is_last = (i == len(entries) - 1)
            connector = "└── " if is_last else "├── "
            line = indent + connector + entry.name
            lines.append(line)
            if entry.is_dir():
                new_indent = indent + ("    " if is_last else "│   ")
                walk(entry, new_indent)

    # header
    header = f"{project_root.name}/"
    lines.append(header)
    walk(project_root, "")
    return "\n".join(lines) + "\n"


def hash_text(s: str) -> str:
    return hashlib.sha1(s.encode("utf-8")).hexdigest()


def main():
    parser = argparse.ArgumentParser(description="Generate and optionally watch project tree (respects .gitignore).")
    parser.add_argument("--watch", action="store_true", help="Run in watch mode (polling).")
    parser.add_argument("--interval", type=float, default=5.0, help="Polling interval in seconds for watch mode.")
    parser.add_argument("--out", type=str, default=OUTPUT_FILE, help="Output file name.")
    args = parser.parse_args()

    project_root = pathlib.Path.cwd()
    out_path = project_root / args.out

    print(f"Project root: {project_root}")
    gitignore_patterns = load_gitignore(project_root)
    print(f"Loaded {len(gitignore_patterns)} .gitignore patterns (if file exists).")

    prev_hash = None

    def regen_and_write():
        nonlocal prev_hash
        gitignore = load_gitignore(project_root)
        tree_text = build_tree(project_root, gitignore)
        h = hash_text(tree_text)
        if h != prev_hash:
            prev_hash = h
            out_path.write_text(tree_text, encoding="utf-8")
            print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Updated {out_path} (hash {h[:8]})")
        else:
            print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] No change.")

    # initial run
    regen_and_write()

    if args.watch:
        print(f"Watching for changes every {args.interval} seconds. Press Ctrl+C to stop.")
        try:
            while True:
                time.sleep(args.interval)
                regen_and_write()
        except KeyboardInterrupt:
            print("\nWatch stopped by user.")


if __name__ == "__main__":
    main()
